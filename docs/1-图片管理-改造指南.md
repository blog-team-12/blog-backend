# 图片管理改造指南（兼容版、简洁落地）

> 更新补充（聚焦七牛优先与优化项，便于直接落地）

## 一口气改造落地方案（可直接执行）
- 范围与目标：一次性完成删除改造、驱动抽象、配置与模型兼容、七牛上传最小接入，并保留前端与接口兼容。
- 执行顺序（建议 2–4 小时内完成）：
  1) 新建存储驱动接口与本地/七牛驱动骨架。
  2) 增加驱动选择器（基于配置切换 local/qiniu），提供全局单例。
  3) 修改删除路径，统一走驱动 `Delete(key)`；文件不存在视为成功。
  4) 扩展 `models.Image` 增加 `Driver/Key/URL`，读写兼容旧 `Path`。
  5) 更新 `configs/dev.yaml` 增加 `storage` 段与七牛配置，密钥走环境变量。
  6) 可选：切换上传到七牛驱动，统一返回 `StorageObject`（保持接口兼容）。
  7) 优化共享 `http.Client` 与 `http.Transport`，支持高并发连接复用。
  8) 加入错误重试与退避策略，删除 612 视为成功。
  9) 验收与压测（功能、日志、指标），再考虑限流或池化。

### 代码改动清单（文件路径与任务）
- 新增 `pkg/storage/driver.go`：定义 `Driver` 接口与 `StorageObject`。
- 新增 `pkg/storage/local/local.go`：实现本地 `Delete(key)`；上传可暂不改。
- 新增 `pkg/storage/qiniu/qiniu.go`：实现七牛 `Delete(key)`，上传最小实现可选。
- 新增 `pkg/storage/selector.go`：驱动选择与单例管理，供业务调用。
- 修改 `pkg/imageutils/imageUtil.go`：删除逻辑改为驱动调用，提取 `Key`。
- 修改 `internal/models/image.go`：新增 `Driver/Key/URL` 字段与读写策略。
- 修改 `configs/dev.yaml`：新增 `storage` 配置段与默认 `current_driver=local`。

### 配置与驱动选择（示例）
```yaml
storage:
  current_driver: local   # 上线前切到 qiniu
  local:
    root: ./static/images
  qiniu:
    access_key: ${QINIU_AK}
    secret_key: ${QINIU_SK}
    bucket:     manpao-img
    domain:     https://img.example.com
  limits:
    max_size:  10MB
```

```go
// pkg/storage/selector.go
package storage

import (
    "sync"
    "manpao-service/pkg/globals"
    "manpao-service/pkg/storage/local"
    qn "manpao-service/pkg/storage/qiniu"
)

var (
    once     sync.Once
    current  Driver
)

// InitFromConfig 初始化当前驱动（单例）
func InitFromConfig() {
    once.Do(func() {
        switch globals.SConfig.Storage.CurrentDriver {
        case "qiniu":
            current = qn.New()
        default:
            current = local.New()
        }
    })
}

// Current 获取当前驱动
func Current() Driver { return current }
```

在初始化流程中调用：
```go
// inits/staticInit.go 或 inits/init.go 的合适位置
import (
    "manpao-service/pkg/storage"
)

func Init() {
    // ... 已有初始化
    storage.InitFromConfig()
}
```

### 删除路径改造（统一走驱动）
```go
// pkg/imageutils/imageUtil.go（示意）
import (
    "context"
    "strings"
    "manpao-service/pkg/storage"
)

func removeImageByURL(u string) error {
    key := extractKey(u) // 去掉 /images/ 前缀，保留相对层级
    if key == "" { return nil }
    drv := storage.Current()
    if drv == nil { return nil }
    return drv.Delete(context.Background(), key)
}

func extractKey(u string) string {
    i := strings.Index(u, "/images/")
    if i >= 0 { return u[i+len("/images/"):] }
    parts := strings.Split(u, "/")
    if len(parts) == 0 { return "" }
    return parts[len(parts)-1]
}
```

### 模型扩展与迁移（兼容读写）
```go
// internal/models/image.go（示意，按你的 GORM tag 调整）
type Image struct {
    Path string
    Name string
    Type string
    Size int64

    Driver string `gorm:"column:driver" json:"driver,omitempty"`
    Key    string `gorm:"column:key" json:"key,omitempty"`
    URL    string `gorm:"column:url" json:"url,omitempty"`
}

// 写入：维持 Path，同时可选写 Driver/Key/URL
// 读取：优先 URL，空则回退 Path
```

迁移（示例）：
```go
// inits/dbInit.go 的合适位置
db.AutoMigrate(&models.Image{})
```

### 七牛上传（可选最小接入）
```go
// 使用驱动上传，统一返回 StorageObject
obj, err := storage.Current().Upload(ctx, fileReader, filename)
if err != nil { /* 记录日志与错误返回 */ }
// 将 obj.Key/obj.URL/obj.Name 写入模型；Path 可与 URL 同步写入保持兼容
```

### 高并发与错误处理（与前文规范一致）
- 共享 `http.Client` 与调优的 `http.Transport`。
- 删除对七牛返回 612 视为成功；上传/删除错误做少量重试与指数退避。
- 先不做限流；压测出现 429/5xx、CPU/GC 占比异常等，再引入 `semaphore` 限并发或小容量通道池。

### 验收清单（快速核对）
- 删除统一走驱动；本地与七牛资源不存在均视为成功。
- 上传后访问地址兼容：local 走 `/images/...`；qiniu 走 `https://domain/<Key>`。
- 更新图片时旧资源实际删除；数据库字段更新正确。
- 接口与前端零改动；日志中不再出现自调用 HTTP 删除。
- 压测下连接稳定、错误率可控；必要时再做限流。

## 对象池与 sync.Pool 取舍（可选，速览）
- 阶段 1、2 无需对象池：本地与驱动删除均为轻量操作。
- 切到七牛并有高并发上传时，可用“通道池”做并发限流与上传器复用；删除仍不需要池。
- 不建议用 `sync.Pool` 管理网络客户端：它用于临时对象重用，可能被 GC 清空，且不提供并发限流与容量控制。
- 简易池示例（可选）：
```go
type DriverPool struct {
    ch  chan storage.Driver
    new func() storage.Driver
}
func New(size int, newFn func() storage.Driver) *DriverPool {
    p := &DriverPool{ch: make(chan storage.Driver, size), new: newFn}
    for i := 0; i < size; i++ { p.ch <- newFn() }
    return p
}
func (p *DriverPool) Get(ctx context.Context) (storage.Driver, error) {
    select { case d := <-p.ch: return d, nil; case <-ctx.Done(): return nil, ctx.Err() }
}
func (p *DriverPool) Put(d storage.Driver) { select { case p.ch <- d: default: } }
```

---

## 高并发不限流方案（驱动与 sync.Pool 规范）
- 目标：在不做限流的前提下，稳健承载上传/删除高并发，避免不必要复杂度。
- 核心策略：
  - 驱动/客户端单例复用，共享 `http.Client` 和 SDK 组件。
  - 流式上传，业务层做类型/尺寸校验后直接传 `io.Reader`。
  - `sync.Pool` 仅用于临时内存对象（`bytes.Buffer`、`[]byte`），不用于“客户端/上传器”这类资源。
  - 调优 `http.Transport` 提高连接复用与并发承载。
- HTTP 客户端调优示例：
```go
var SharedHTTP = &http.Client{
    Transport: &http.Transport{
        MaxIdleConns:        1024,
        MaxIdleConnsPerHost: 256,
        IdleConnTimeout:     90 * time.Second,
        TLSHandshakeTimeout: 10 * time.Second,
        ExpectContinueTimeout: 1 * time.Second,
    },
    Timeout: 0, // 超时由业务控制
}
```
- 驱动单例示例：
```go
type QiniuDriver struct {
    mac    *qbox.Mac
    cfg    qnstorage.Config
    bm     *qnstorage.BucketManager
    domain string
    bucket string
}
func NewQiniuDriver() *QiniuDriver {
    mac := qbox.NewMac(ak, sk)
    cfg := qnstorage.Config{UseHTTPS: true, UseCdnDomains: true}
    bm := qnstorage.NewBucketManager(mac, &cfg)
    return &QiniuDriver{mac: mac, cfg: cfg, bm: bm, domain: domain, bucket: bucket}
}
```
- 临时缓冲使用 `sync.Pool` 示例：
```go
var bufPool = sync.Pool{New: func() any { return new(bytes.Buffer) }}
var bytesPool = sync.Pool{New: func() any { return make([]byte, 64<<10) }} // 64KB

func getBuf() *bytes.Buffer {
    b := bufPool.Get().(*bytes.Buffer)
    b.Reset()
    return b
}
func putBuf(b *bytes.Buffer) { bufPool.Put(b) }

func getBytes() []byte { return bytesPool.Get().([]byte) }
func putBytes(b []byte) { bytesPool.Put(b) }
```
- 错误与回退建议：
  - 针对网络/服务端错误做“少量重试 + 指数退避”，删除 612 视为成功。
  - 打通日志与告警，监控 429/5xx、超时与重试率。
- 何时再考虑限流或池：
  - 压测显示连接抖动、CPU/GC 占比过高、错误码密集时，再加 `semaphore` 限并发；上传器初始化昂贵且可复用时再考虑小容量通道池。
- 快速行动清单：
  - 初始化单例驱动与共享 `http.Client`。
  - 上传走 `io.Reader`，减少内存拷贝。
  - 在构建 multipart/缓冲时用 `sync.Pool` 复用临时对象。
  - 加入重试与退避策略，记录关键指标。

本补充在不改变原有“分阶段、兼容、简洁”的原则下，优先支持七牛云并明确本次要做的修改与优化点，避免引入无关功能。内容包含：优化摘要、七牛驱动最小实现、配置样例、模型兼容策略、开发快速清单与验收要点。

## 优化摘要（本次新增/调整）
- 明确存储驱动选择：通过配置 `storage.current_driver` 在 `local` 与 `qiniu` 间切换（默认为 `local`，上线时切到 `qiniu`）。
- 删除路径统一走驱动：现有删除逻辑替换为 `driver.Delete(key)`，本地与云端行为一致；不存在文件视为成功。
- 保留上传兼容：现阶段上传沿用旧逻辑；当 `current_driver=qiniu` 时可在业务层写入 `Driver/Key/URL` 字段以便回读兼容（`Path` 仍写）。
- URL/Key 规则统一：
  - `Key`：相对键（如 `2025/11/10/xxx.png`），不含 `/images/` 前缀。
  - `URL`：对 `local` 为 `/images/<Key>`；对 `qiniu` 为 `https://<domain>/<Key>`（可选使用 CDN 域名）。
- 模型前向兼容：`models.Image` 新增 `Driver/Key/URL` 字段；读取优先 `URL`，为空回退 `Path`；写入暂维持 `Path`，可同步写 `Driver/Key/URL`。
- 配置集中管理：新增 `storage` 配置段（`local.root`、`qiniu.access_key/secret_key/bucket/domain`、`limits.max_size`、`current_driver`）。

---

## 七牛驱动：最小实现示例（删除必做，上传可择机）

目录建议：
- `pkg/storage/driver.go`
- `pkg/storage/local/local.go`
- `pkg/storage/qiniu/qiniu.go`

接口（精简版，与原文一致，补充注释）：
```go
// pkg/storage/driver.go
package storage

import (
    "context"
    "io"
)

type StorageObject struct {
    Key  string // 存储键（相对路径）
    URL  string // 可访问 URL（local: /images/<Key>；qiniu: https://domain/<Key>）
    Size int64
    Type string
    Name string
}

type Driver interface {
    Name() string
    Delete(ctx context.Context, key string) error
    Upload(ctx context.Context, r io.Reader, filename string) (StorageObject, error)
}
```

本地实现（删除直达）：
```go
// pkg/storage/local/local.go
package local

import (
    "context"
    "os"
    "path/filepath"

    // 注意：按你的 module 实际路径调整
    "manpao-service/pkg/globals"
    "manpao-service/pkg/storage"
)

type LocalDriver struct{}

func New() *LocalDriver { return &LocalDriver{} }
func (d *LocalDriver) Name() string { return "local" }

func (d *LocalDriver) Delete(ctx context.Context, key string) error {
    real := filepath.Join(globals.SConfig.Path, key)
    if err := os.Remove(real); err != nil {
        if os.IsNotExist(err) { return nil }
        return err
    }
    return nil
}

func (d *LocalDriver) Upload(ctx context.Context, r io.Reader, filename string) (storage.StorageObject, error) {
    // 现阶段沿用旧上传逻辑，此处不做实现
    return storage.StorageObject{}, fmt.Errorf("not implemented: keep using existing upload flow")
}
```

七牛实现（先打删除闭环，上传可择机切换）：
```go
// pkg/storage/qiniu/qiniu.go
package qiniu

import (
    "context"
    "fmt"
    "io"

    qbox "github.com/qiniu/api.v7/auth/qbox"
    qnstorage "github.com/qiniu/api.v7/storage"

    // 注意：按你的 module 实际路径调整
    "manpao-service/pkg/globals"
    "manpao-service/pkg/storage"
)

type QiniuDriver struct {
    ak     string
    sk     string
    bucket string
    domain string // 访问域名（含协议），如 https://img.example.com
}

func New() *QiniuDriver {
    cfg := globals.SConfig // 按你的配置结构取值
    return &QiniuDriver{
        ak:     cfg.Storage.Qiniu.AccessKey,
        sk:     cfg.Storage.Qiniu.SecretKey,
        bucket: cfg.Storage.Qiniu.Bucket,
        domain: cfg.Storage.Qiniu.Domain,
    }
}

func (d *QiniuDriver) Name() string { return "qiniu" }

func (d *QiniuDriver) Delete(ctx context.Context, key string) error {
    mac := qbox.NewMac(d.ak, d.sk)
    cfg := qnstorage.Config{UseHTTPS: true, UseCdnDomains: true}
    bm := qnstorage.NewBucketManager(mac, &cfg)
    if err := bm.Delete(d.bucket, key); err != nil {
        // 七牛返回 612 表示资源不存在：视为成功
        if _, ok := err.(*qnstorage.ErrorInfo); ok {
            if err.(*qnstorage.ErrorInfo).Code == 612 { return nil }
        }
        return err
    }
    return nil
}

func (d *QiniuDriver) Upload(ctx context.Context, r io.Reader, filename string) (storage.StorageObject, error) {
    mac := qbox.NewMac(d.ak, d.sk)
    putPolicy := qnstorage.PutPolicy{Scope: d.bucket}
    upToken := putPolicy.UploadToken(mac)

    cfg := qnstorage.Config{UseHTTPS: true, UseCdnDomains: true}
    formUploader := qnstorage.NewFormUploader(&cfg)
    ret := qnstorage.PutRet{}

    // filename 建议用业务生成的 key（含日期层级），与旧规则一致
    if err := formUploader.Put(ctx, &ret, upToken, filename, r, -1, &qnstorage.PutExtra{}); err != nil {
        return storage.StorageObject{}, err
    }
    obj := storage.StorageObject{
        Key:  ret.Key,
        URL:  fmt.Sprintf("%s/%s", d.domain, ret.Key),
        Name: filename,
        // Size/Type 可由业务层补充（读取 header 或探测）
    }
    return obj, nil
}
```

---

## 配置样例（dev.yaml）

```yaml
storage:
  current_driver: local   # 上线前切到 qiniu
  local:
    root: ./static/images # 与 globals.SConfig.Path 一致
  qiniu:
    access_key: ${QINIU_AK}
    secret_key: ${QINIU_SK}
    bucket:     manpao-img
    domain:     https://img.example.com
  limits:
    max_size:  10MB
```

使用说明：
- secrets 用环境变量注入，避免写入代码库。
- 切换到七牛时仅需改 `current_driver` 与保证上述字段可读。

---

## 模型与兼容策略（`internal/models/image.go`）

建议新增字段（示意）：
```go
// 按你的模型风格调整 tag
type Image struct {
  // ... 原有字段
  Path   string
  Name   string
  Type   string
  Size   int64

  Driver string `gorm:"column:driver" json:"driver,omitempty"`
  Key    string `gorm:"column:key" json:"key,omitempty"`
  URL    string `gorm:"column:url" json:"url,omitempty"`
}
```

读写策略：
- 写入：维持写 `Path=/images/<Key>`；当可用时同步写 `Driver`（local/qiniu）、`Key`（相对键）、`URL`（local 为 `/images/<Key>`；qiniu 为 `domain/<Key>`）。
- 读取：优先 `URL`，为空回退 `Path`。
- 迁移：`AutoMigrate` 增加新列即可，不动旧列。

---

## 业务改造要点（删除改造必做，上传保持兼容）

- 删除逻辑：
  - 在 `pkg/imageutils/imageUtil.go` 的删除路径中，提取 `Key`（去掉 `/images/` 前缀），调用当前驱动 `Delete(ctx, key)`。
  - 将文件不存在视为成功（local: `os.IsNotExist`；qiniu: 612）。
- 上传逻辑（现阶段）：
  - 沿用现有上传；如 `current_driver=qiniu` 并选择切换上传，可调用 `qiniu.Upload(reader, filename)` 并将返回的 `URL/Key/Driver` 写入模型；否则继续写 `Path` 并同步可得的 `Driver/Key/URL`。
- URL 统一：
  - local: `URL = "/images/" + Key`
  - qiniu: `URL = domain + "/" + Key`

---

## 开发快速清单（文件级）

- 新增 `pkg/storage/driver.go`（接口与 `StorageObject`）。
- 新增 `pkg/storage/local/local.go`（实现 `Delete`，`Upload` 留空或抛未实现）。
- 新增 `pkg/storage/qiniu/qiniu.go`（实现 `Delete`；`Upload` 可择机实现）。
- 修改 `pkg/imageutils/imageUtil.go`（删除路径改为驱动调用；提取 `Key`）。
- 修改 `internal/models/image.go`（新增 `Driver/Key/URL` 字段）。
- 修改 `configs/dev.yaml`（新增 `storage` 段及所需字段）。

---

## 验收要点

- 本地与七牛删除均通过驱动执行；不存在文件/资源不报错。
- 上传后页面访问不受影响：local 仍走 `/images/...`；qiniu 使用配置域名访问。
- 更新图片时旧文件（local）或旧资源（qiniu）实际被删除；数据库记录更新正确。
- 控制器/接口不变，前端零改动；日志不再出现自调用 HTTP 删除。

---

以上补充与优化与原“三阶段改造”保持一致：
- 阶段 1 仍先修复删除（local 直达）。
- 阶段 2 抽象驱动并在删除路径落地，追加七牛驱动实现以便快速切换。
- 阶段 3 扩展模型字段以实现前向兼容，减少未来切换成本。


面向现有代码库，分阶段、小步快跑地完成图片管理的“可靠删除 + 适配层抽象 + 前向兼容”，不引入多余功能，确保现有接口不变、前端零感知。

## 总目标与原则
- 保持路由与响应兼容：`POST /image/upload` 与静态前缀 `/images` 维持不变。
- 简化落地：优先修复删除与清理问题；适配层只做最小闭环。
- 数据前向兼容：新增字段不破坏旧数据；读取优先新字段，回退旧字段。
- 可回滚：每个阶段可独立发布与回滚。

## 改造总览（3 阶段）
- 阶段 1：修复删除机制（避免自调用 HTTP，直接本地删除）。
- 阶段 2：抽象简化的存储驱动接口，并在删除路径中使用驱动（上传暂保持原逻辑）。
- 阶段 3：扩展 `models.Image` 字段，读写兼容，为后续多驱动打底。

---

## 阶段 1：修复删除机制（本地删除直达）

目的：解决旧文件清理不彻底的问题，删除不再依赖“服务自调用 HTTP”。

改动文件与位置：`pkg/imageutils/imageUtil.go`

必要修改点：
- 删除或停用：`sendDeleteRequest()`、`buildDeleteURL()` 的调用链。
- 更新 `removeLocalImage(path string)`：直接用 `os.Remove()` 删除本地文件。
- 计算真实文件路径：基于 `globals.SConfig.Path` 与提取到的文件名拼接。
- 不存在时不报错：将 `os.IsNotExist` 视为可接受。

参考实现片段（示意）：
```go
import (
    "os"
    "path/filepath"
    "strings"
)

func removeLocalImage(path string) error {
    // path 可能是 "/images/2025/11/10/xxx.png"，仅保留文件名或相对层级
    filename := extractFilename(path) // 自有函数：截取最后一段或相对路径部分
    if filename == "" { return nil }

    // 真实磁盘路径：globals.SConfig.Path + 相对层级（保持与上传目录结构一致）
    real := filepath.Join(globals.SConfig.Path, filename)
    if err := os.Remove(real); err != nil {
        if os.IsNotExist(err) { return nil }
        return err
    }
    return nil
}

func extractFilename(u string) string {
    // 去掉前缀，例如 /images/ 前缀（按你的规范），保留后续层级
    i := strings.Index(u, "/images/")
    if i >= 0 { return u[i+len("/images/"):] }
    // 兜底：只取最后一段
    parts := strings.Split(u, "/")
    if len(parts) == 0 { return "" }
    return parts[len(parts)-1]
}
```

验收标准：
- 更新产品/用户头像时，旧文件从 `./static/images` 中被实际删除。
- 批量删除不抛错；日志不再出现针对 `/api/admin/image/delete/...` 的调用。
- 若文件不存在，删除流程返回成功，不影响事务提交。

---

## 阶段 2：加入最小存储驱动适配（删除用驱动）

目的：在不重写上传的前提下，把“删除能力”下沉到驱动，形成最小闭环，后续可平滑接入云端驱动。

新增文件建议：
- `pkg/storage/driver.go`
- `pkg/storage/local/local.go`

接口与本地实现（精简版）：
```go
// pkg/storage/driver.go
package storage

import (
    "context"
    "io"
)

type StorageObject struct {
    Key  string // 存储键（相对路径）
    URL  string // 可访问 URL（例如 /images/...）
    Size int64
    Type string
    Name string
}

type Driver interface {
    Name() string
    Delete(ctx context.Context, key string) error
    // 上传接口暂不强行改造现有逻辑，可预留：
    Upload(ctx context.Context, r io.Reader, filename string) (StorageObject, error)
}
```
```go
// pkg/storage/local/local.go
package local

import (
    "context"
    "fmt"
    "os"
    "path/filepath"

    "your-project/pkg/globals"
    "your-project/pkg/storage"
)

type LocalDriver struct{}

func New() *LocalDriver { return &LocalDriver{} }
func (d *LocalDriver) Name() string { return "local" }

func (d *LocalDriver) Delete(ctx context.Context, key string) error {
    // key 例如："2025/11/10/xxx.png"（不含 /images/ 前缀）
    real := filepath.Join(globals.SConfig.Path, key)
    if err := os.Remove(real); err != nil {
        if os.IsNotExist(err) { return nil }
        return err
    }
    return nil
}

// 预留上传，后续接入时使用
func (d *LocalDriver) Upload(ctx context.Context, r io.Reader, filename string) (storage.StorageObject, error) {
    return storage.StorageObject{}, fmt.Errorf("not implemented: use existing upload flow for now")
}
```

在删除路径中使用驱动（不改上传）：
- 在 `pkg/imageutils/imageUtil.go` 的 `removeLocalImage()` 中，不再直接 `os.Remove`，改为：
  - 提取 `key`（相对路径，如 `2025/11/10/xxx.png`）。
  - `driver := local.New()`（可做成单例），`driver.Delete(ctx, key)`。
- 保持远程删除为“跳过/记录日志”（未来接入云驱动时完成）。

验收标准：
- 删除路径通过驱动执行；本地与将来的云存储语义统一为 Delete(key)。
- 不影响现有上传与访问；前端仍使用 `/images/...`。

---

## 阶段 3：扩展 models.Image（前向兼容）

目的：为未来多驱动打底，同时不影响现有读写。

改动文件：`internal/models/image.go`

建议新增字段：
```go
// 伪代码：按你的模型风格调整 tag
// type Image struct {
//   gorm.Model
//   Type string
//   Size int64
//   Path string // 旧字段，保留
//   Name string
// 
//   Driver string `gorm:"column:driver" json:"driver,omitempty"`
//   Key    string `gorm:"column:key" json:"key,omitempty"`
//   URL    string `gorm:"column:url" json:"url,omitempty"`
// }
```

读写兼容策略：
- 写入：现阶段继续写 `Path`（`/images/...`）。如易得，可同步填充 `Driver=local`、`Key`（相对路径）、`URL`（与 Path 一致）。
- 读取：优先使用 `URL`；为空则回退到 `Path`。
- 迁移：使用 GORM AutoMigrate 增加新列（不删除旧列）。

验收标准：
- 旧数据不受影响；新数据写入时可选填充新字段。
- 控制器响应不变（前端零改动）。

---

## 变更清单（文件级）
- 修改：`pkg/imageutils/imageUtil.go`（阶段 1 必做；阶段 2 替换删除为驱动调用）。
- 新增：`pkg/storage/driver.go`（阶段 2）。
- 新增：`pkg/storage/local/local.go`（阶段 2）。
- 修改：`internal/models/image.go`（阶段 3，可延后）。

---

## 测试与验收
- 单元测试（建议）：
  - `removeLocalImage()` 在存在/不存在文件下的行为。
  - `local.Driver.Delete(key)` 行为（路径正确、不存在不报错）。
- 手工集成测试：
  - 上传图片，拿到 `/images/...`；确认磁盘存在对应文件。
  - 更新图片：新旧文件对比，旧文件被删除；数据库记录更新。
  - 批量删除：无异常；静态目录空间稳定增长（无残留）。
- 日志核对：
  - 不再出现 `DELETE /api/admin/image/delete/...` 的调用日志。
  - 对远程 URL 删除，记录“暂不支持”的提示即可。

---

## 回滚策略
- 阶段 1：如需回滚，恢复到旧的 `sendDeleteRequest()` 实现（不推荐）。
- 阶段 2：删除驱动目录与引用，恢复为直接 `os.Remove`。
- 阶段 3：保留新增列不会影响旧逻辑；如需禁用，仅停止写入新字段即可。

---

## 后续计划（可选，不在本次范围）
- 将上传改造为驱动 `Upload(reader)`，统一返回 `StorageObject`（含 URL/Key/Size/Type）。
- 引入云存储驱动（七牛/OSS 等），通过配置切换当前驱动。
- 后台管理入口（列表/预览/删除/批量清理）仍走驱动删除，不再拼文件名 URL。

---

## 总结
- 先解决“删除不可靠”的核心问题，形成最小闭环。
- 在不影响现有上传与访问的前提下，抽象删除到驱动层，为未来扩展留好接口。
- 通过新增模型字段实现前向兼容，控制修改范围与复杂度。

按本指南逐步实施，每一阶段都能独立上线与验证，确保稳定、简洁、可迭代。